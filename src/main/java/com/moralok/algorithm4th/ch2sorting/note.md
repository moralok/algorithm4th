排序成本模型。在研究排序算法时，我们需要计算**比较**和**交换**的数量。对于不交换元素的算法，我们会计算访问数组的次数。

## 选择排序
运行时间和输入无关。
数据移动时最少的。

## 插入排序

运行时间和输入有关。

倒置，指的是数组中的两个顺序颠倒的元素。

部分有序，数组中倒置的数量小于数组大小的某个背书。

插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

适用场景
适用于部分有序和小规模数组（其他考虑因素，例如空间和重复主键）。

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

插入排序内循环优化：减半访问数组次数。


## 希尔排序
基于插入排序的快速的排序算法。
插入排序对于大规模乱序数组插入排序很慢，因其只会交换相邻的元素，每次只减少一对倒置的元素。希尔排序通过交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。 

h 有序数组，希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组，h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。

对于任意以 1 结尾的 h 序列，我们都能够将数组排序。h 序列可以实时计算，也可以提前将递增序列存储在一个数组中。书中使用 `1/2*(3^k-1)`。

h 递增序列暂无定论。

对于中等大小的数组，运行时间可接受，不到平方级别（书中的算法最坏情况下为 `n^3/2`）。
代码量小。
不需要额外的内存空间。

## 归并排序
归并，将两个有序的数组归并成一个更大的有序数组。
分治思想的典型例子。
要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。

优点是能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比。
缺点是需要的额外空间和 N 成正比。

自顶向下的归并排序。
自底向上的归并排序。适用于用链表组织的数据。

对于长度为 N 的任意数组，自顶向下（自底向上）的归并排序需要 1/2*NlgN 至 NlgN 次比较。
归纳法证明
对于大小为 0 和 1 的数组，排序需要访问数组 0 次。
对于大小为 N 的数组，列出上下界不等式。
以 N 为 2 的 n 次方，求特解。
普遍形式不会。

对于长度为 N 的任意数组，自顶向下（自底向上）的归并排序最多需要访问数组 6NlgN 次。
归并排序中没有交换步骤，因此分析时，采用计算访问数组的次数的方式。


没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN 次比较将长度为 N 的数组排序。
证明，比较树至少有 N! 个叶子节点，树高大于等于 lg(N!)，根据斯特灵公式 lg(N!) ~ NlgN。

归并排序是一种渐进最优的基于比较排序的算法。